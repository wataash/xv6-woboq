<!doctype html>
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1.0"><title>entryother.S source code [xv6/entryother.S] - Woboq Code Browser</title>
<link rel="stylesheet" href="https://code.woboq.org/data/qtcreator.css" title="QtCreator"/>
<link rel="alternate stylesheet" href="https://code.woboq.org/data/kdevelop.css" title="KDevelop"/>
<script type="text/javascript" src="https://code.woboq.org/data/jquery/jquery.min.js"></script>
<script type="text/javascript" src="https://code.woboq.org/data/jquery/jquery-ui.min.js"></script>
<script>var file = 'xv6/entryother.S'; var root_path = '..'; var data_path = 'https://code.woboq.org/data';</script>
<script src='https://code.woboq.org/data/codebrowser.js'></script>
</head>
<body><div id='header'><h1 id='breadcrumb'><span>Browse the source code of </span><a href='./'>xv6</a>/<a href='entryother.S.html'>entryother.S</a></h1></div>
<hr/><div id='content'><table class="code">
<tr><th id="1">1</th><td><u>#include <a href="asm.h.html">"asm.h"</a></u></td></tr>
<tr><th id="2">2</th><td><u>#include <a href="memlayout.h.html">"memlayout.h"</a></u></td></tr>
<tr><th id="3">3</th><td><u>#include <a href="mmu.h.html">"mmu.h"</a></u></td></tr>
<tr><th id="4">4</th><td>	</td></tr>
<tr><th id="5">5</th><td><u><span class='error' title="expected identifier or &apos;(&apos;">#</span> Each non-boot CPU ("AP") is started up in response to a STARTUP</u></td></tr>
<tr><th id="6">6</th><td><u># IPI from the boot CPU.  Section B.4.2 of the Multi-Processor</u></td></tr>
<tr><th id="7">7</th><td><u># Specification says that the AP will start in real mode with CS:IP</u></td></tr>
<tr><th id="8">8</th><td><u># set to XY00:0000, where XY is an 8-bit value sent with the</u></td></tr>
<tr><th id="9">9</th><td><u># STARTUP. Thus this code must start at a 4096-byte boundary.</u></td></tr>
<tr><th id="10">10</th><td><u>#</u></td></tr>
<tr><th id="11">11</th><td><u># Because this code sets DS to zero, it must sit</u></td></tr>
<tr><th id="12">12</th><td><u># at an address in the low 2^16 bytes.</u></td></tr>
<tr><th id="13">13</th><td><u>#</u></td></tr>
<tr><th id="14">14</th><td><u># Startothers (in main.c) sends the STARTUPs one at a time.</u></td></tr>
<tr><th id="15">15</th><td><u># It copies this code (start) at 0x7000.  It puts the address of</u></td></tr>
<tr><th id="16">16</th><td><u># a newly allocated per-core stack in start-4,the address of the</u></td></tr>
<tr><th id="17">17</th><td><u># place to jump to (mpenter) in start-8, and the physical address</u></td></tr>
<tr><th id="18">18</th><td><u># of entrypgdir in start-12.</u></td></tr>
<tr><th id="19">19</th><td><u>#</u></td></tr>
<tr><th id="20">20</th><td><u># This code combines elements of bootasm.S and entry.S.</u></td></tr>
<tr><th id="21">21</th><td></td></tr>
<tr><th id="22">22</th><td>.code16           </td></tr>
<tr><th id="23">23</th><td>.globl start</td></tr>
<tr><th id="24">24</th><td>start:</td></tr>
<tr><th id="25">25</th><td>  cli            </td></tr>
<tr><th id="26">26</th><td></td></tr>
<tr><th id="27">27</th><td>  <u># Zero data segment registers DS, ES, and SS.</u></td></tr>
<tr><th id="28">28</th><td>  xorw    %ax,%ax</td></tr>
<tr><th id="29">29</th><td>  movw    %ax,%ds</td></tr>
<tr><th id="30">30</th><td>  movw    %ax,%es</td></tr>
<tr><th id="31">31</th><td>  movw    %ax,%ss</td></tr>
<tr><th id="32">32</th><td></td></tr>
<tr><th id="33">33</th><td>  <u># Switch from real to protected mode.  Use a bootstrap GDT that makes</u></td></tr>
<tr><th id="34">34</th><td>  <u># virtual addresses map directly to physical addresses so that the</u></td></tr>
<tr><th id="35">35</th><td>  <u># effective memory map doesn't change during the transition.</u></td></tr>
<tr><th id="36">36</th><td>  lgdt    gdtdesc</td></tr>
<tr><th id="37">37</th><td>  movl    %cr0, %eax</td></tr>
<tr><th id="38">38</th><td>  orl     $<a class="macro" href="mmu.h.html#8" title="0x00000001" data-ref="_M/CR0_PE">CR0_PE</a>, %eax</td></tr>
<tr><th id="39">39</th><td>  movl    %eax, %cr0</td></tr>
<tr><th id="40">40</th><td></td></tr>
<tr><th id="41">41</th><td>  <u># Complete the transition to 32-bit protected mode by using a long jmp</u></td></tr>
<tr><th id="42">42</th><td>  <u># to reload %cs and %eip.  The segment descriptors are set up with no</u></td></tr>
<tr><th id="43">43</th><td>  <u># translation, so that the mapping is still the identity mapping.</u></td></tr>
<tr><th id="44">44</th><td>  ljmpl    $(<a class="macro" href="mmu.h.html#15" title="1" data-ref="_M/SEG_KCODE">SEG_KCODE</a>&lt;&lt;<var>3</var>), $(start32)</td></tr>
<tr><th id="45">45</th><td></td></tr>
<tr><th id="46">46</th><td><i>//PAGEBREAK!</i></td></tr>
<tr><th id="47">47</th><td>.code32  # Tell assembler to generate <var>32</var>-bit code now.</td></tr>
<tr><th id="48">48</th><td>start32:</td></tr>
<tr><th id="49">49</th><td>  <u># Set up the protected-mode data segment registers</u></td></tr>
<tr><th id="50">50</th><td>  movw    $(<a class="macro" href="mmu.h.html#16" title="2" data-ref="_M/SEG_KDATA">SEG_KDATA</a>&lt;&lt;<var>3</var>), %ax    # Our data segment selector</td></tr>
<tr><th id="51">51</th><td>  movw    %ax, %ds                # -&gt; DS: Data Segment</td></tr>
<tr><th id="52">52</th><td>  movw    %ax, %es                # -&gt; ES: Extra Segment</td></tr>
<tr><th id="53">53</th><td>  movw    %ax, %ss                # -&gt; SS: Stack Segment</td></tr>
<tr><th id="54">54</th><td>  movw    $<var>0</var>, %ax                 # Zero segments not ready <b>for</b> use</td></tr>
<tr><th id="55">55</th><td>  movw    %ax, %fs                # -&gt; FS</td></tr>
<tr><th id="56">56</th><td>  movw    %ax, %gs                # -&gt; GS</td></tr>
<tr><th id="57">57</th><td></td></tr>
<tr><th id="58">58</th><td>  <u># Turn on page size extension for 4Mbyte pages</u></td></tr>
<tr><th id="59">59</th><td>  movl    %cr4, %eax</td></tr>
<tr><th id="60">60</th><td>  orl     $(<a class="macro" href="mmu.h.html#12" title="0x00000010" data-ref="_M/CR4_PSE">CR4_PSE</a>), %eax</td></tr>
<tr><th id="61">61</th><td>  movl    %eax, %cr4</td></tr>
<tr><th id="62">62</th><td>  <u># Use entrypgdir as our initial page table</u></td></tr>
<tr><th id="63">63</th><td>  movl    (start-<var>12</var>), %eax</td></tr>
<tr><th id="64">64</th><td>  movl    %eax, %cr3</td></tr>
<tr><th id="65">65</th><td>  <u># Turn on paging.</u></td></tr>
<tr><th id="66">66</th><td>  movl    %cr0, %eax</td></tr>
<tr><th id="67">67</th><td>  orl     $(<a class="macro" href="mmu.h.html#8" title="0x00000001" data-ref="_M/CR0_PE">CR0_PE</a>|<a class="macro" href="mmu.h.html#10" title="0x80000000" data-ref="_M/CR0_PG">CR0_PG</a>|<a class="macro" href="mmu.h.html#9" title="0x00010000" data-ref="_M/CR0_WP">CR0_WP</a>), %eax</td></tr>
<tr><th id="68">68</th><td>  movl    %eax, %cr0</td></tr>
<tr><th id="69">69</th><td></td></tr>
<tr><th id="70">70</th><td>  <u># Switch to the stack allocated by startothers()</u></td></tr>
<tr><th id="71">71</th><td>  movl    (start-<var>4</var>), %esp</td></tr>
<tr><th id="72">72</th><td>  <u># Call mpenter()</u></td></tr>
<tr><th id="73">73</th><td>  call	 *(start-<var>8</var>)</td></tr>
<tr><th id="74">74</th><td></td></tr>
<tr><th id="75">75</th><td>  movw    $<var>0x8a00</var>, %ax</td></tr>
<tr><th id="76">76</th><td>  movw    %ax, %dx</td></tr>
<tr><th id="77">77</th><td>  outw    %ax, %dx</td></tr>
<tr><th id="78">78</th><td>  movw    $<var>0x8ae0</var>, %ax</td></tr>
<tr><th id="79">79</th><td>  outw    %ax, %dx</td></tr>
<tr><th id="80">80</th><td>spin:</td></tr>
<tr><th id="81">81</th><td>  jmp     spin</td></tr>
<tr><th id="82">82</th><td></td></tr>
<tr><th id="83">83</th><td>.p2align <var>2</var></td></tr>
<tr><th id="84">84</th><td>gdt:</td></tr>
<tr><th id="85">85</th><td>  <a class="macro" href="asm.h.html#5" title=".word 0, 0; .byte 0, 0, 0, 0" data-ref="_M/SEG_NULLASM">SEG_NULLASM</a></td></tr>
<tr><th id="86">86</th><td>  <a class="macro" href="asm.h.html#11" title=".word (((0xffffffff) &gt;&gt; 12) &amp; 0xffff), ((0) &amp; 0xffff); .byte (((0) &gt;&gt; 16) &amp; 0xff), (0x90 | (0x8|0x2)), (0xC0 | (((0xffffffff) &gt;&gt; 28) &amp; 0xf)), (((0) &gt;&gt; 24) &amp; 0xff)" data-ref="_M/SEG_ASM">SEG_ASM</a>(<a class="macro" href="mmu.h.html#56" title="0x8" data-ref="_M/STA_X">STA_X</a>|<a class="macro" href="mmu.h.html#58" title="0x2" data-ref="_M/STA_R">STA_R</a>, <var>0</var>, <var>0xffffffff</var>)</td></tr>
<tr><th id="87">87</th><td>  <a class="macro" href="asm.h.html#11" title=".word (((0xffffffff) &gt;&gt; 12) &amp; 0xffff), ((0) &amp; 0xffff); .byte (((0) &gt;&gt; 16) &amp; 0xff), (0x90 | (0x2)), (0xC0 | (((0xffffffff) &gt;&gt; 28) &amp; 0xf)), (((0) &gt;&gt; 24) &amp; 0xff)" data-ref="_M/SEG_ASM">SEG_ASM</a>(<a class="macro" href="mmu.h.html#57" title="0x2" data-ref="_M/STA_W">STA_W</a>, <var>0</var>, <var>0xffffffff</var>)</td></tr>
<tr><th id="88">88</th><td></td></tr>
<tr><th id="89">89</th><td></td></tr>
<tr><th id="90">90</th><td>gdtdesc:</td></tr>
<tr><th id="91">91</th><td>  .word   (gdtdesc - gdt - <var>1</var>)</td></tr>
<tr><th id="92">92</th><td>  .<em>long</em>   gdt</td></tr>
<tr><th id="93">93</th><td></td></tr>
<tr><th id="94">94</th><td></td></tr>
</table><hr/><p id='footer'>
Generated on <em>2019-Jul-19</em> from project xv6 revision <em>xv6-rev11</em><br />Powered by <a href='https://woboq.com'><img alt='Woboq' src='https://code.woboq.org/woboq-16.png' width='41' height='16' /></a> <a href='https://code.woboq.org'>Code Browser</a> 2.1
<br/>Generator usage only permitted with license.</p>
</div></body></html>
